<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lexicon ‚Äî MTG Pocket Companion</title>
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:#0f172a; color:#ffffff;
    }
    header {
      padding:16px 18px; font-weight:700; font-size:18px; background:#111827; border-bottom:1px solid #1f2937;
      display:flex; justify-content:space-between; align-items:center;
    }
    main { max-width:960px; margin:0 auto; padding:16px; }
    .bar { display:flex; gap:8px; margin-bottom:12px; align-items:flex-start; }
    textarea#prompt {
      flex:1;
      min-height:120px;         /* taller to start */
      max-height:60vh;          /* comfortable limit on phone */
      padding:12px 14px;
      border-radius:10px;
      border:1px solid #334155;
      background:#0b1220;
      color:#ffffff;
      resize:none;               /* we auto-size instead */
      line-height:1.5;
      white-space:pre-wrap;      /* show deck lists with line breaks */
      overflow:auto;             /* infinite scroll as content grows */
    }
    button {
      padding:10px 14px; border-radius:10px; border:1px solid #334155; background:#111827; color:#e5e7eb; cursor:pointer;
    }
    button:hover { background:#0b1220; }
    #log {
      height:480px; overflow:auto; padding:14px; border:1px solid #1f2937; border-radius:12px; background:#0b1220;
    }
    .msg { margin:12px 0; line-height:1.6; }
    .name { font-size:.9rem; margin-bottom:4px; }
    .name.lexicon { color:#4b5563; } /* dark grey */
    .name.you    { color:#f59e0b; }  /* orange */
    .msg h1,.msg h2,.msg h3 { margin:14px 0 8px; line-height:1.2; }
    .msg h3 { font-size:1.05rem; color:#93c5fd; }
    .msg ul { margin:6px 0 10px 1.25em; }
    .msg li { margin:2px 0; }
    .msg strong { color:#e0e7ff; }
    .tip { margin-top:10px; font-size:12px; color:#94a3b8; }
    #preview {
      position:absolute; display:none; z-index:50; border:1px solid #1f2937; border-radius:10px; background:#0b1220; padding:6px;
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
    }
    #preview img { width:320px; max-width:80vw; border-radius:8px; display:block; }
    .card-inline {
      color:#f3f4f6;              /* slightly off-white for hover-able */
      cursor:pointer;
      border-bottom:1px dotted #334155;
      transition:filter .12s ease;
    }
    .card-inline:hover { filter:brightness(1.08); }
    .actions { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .hidden { display:none; }
    /* modal */
    .modal { position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.45); }
    .modal > div { width:min(560px, 92vw); background:#0b1220; border:1px solid #1f2937; border-radius:12px; padding:16px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    label { font-size:14px; color:#cbd5e1; display:block; margin-bottom:4px; }
    input[type="number"], select {
      width:100%; padding:10px; border-radius:10px; border:1px solid #334155; background:#0a1120; color:#e5e7eb;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <header>
    <div>Lexicon ‚Äî MTG Pocket Companion</div>
    <div class="actions">
      <button id="settingsBtn" type="button">‚öôÔ∏è Settings</button>
      <button id="feedbackBtn" type="button">üí¨ Feedback</button>
    </div>
  </header>

  <main>
    <!-- Chat bar with multi-line, auto-expanding textarea -->
    <form id="chatForm" class="bar">
      <textarea id="prompt"
        placeholder="Talk to Lexicon‚Ä¶ (paste a deck list ‚Äî line breaks will be preserved)"
        autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false"></textarea>
      <div style="display:flex; flex-direction:column; gap:8px; align-items:stretch;">
        <button id="speakBtn" type="button">üéôÔ∏è</button>
        <button id="sendBtn" type="submit">Send</button>
        <button id="clearBtn" type="button">Clear</button>
      </div>
    </form>

    <div id="log" aria-live="polite"></div>

    <div class="actions">
      <button id="checkBtn" class="hidden" type="button">üîç Check Legality & Budget</button>
    </div>

    <div class="tip">Tip: paste decklists with line breaks; output uses headings & bullets. Card names are auto-detected for hover.</div>
    <div id="preview"><img alt="card preview"></div>
  </main>

  <!-- Settings modal (unchanged) -->
  <div id="settingsModal" class="modal">
    <div>
      <h3 style="margin:0 0 10px;">Settings</h3>
      <div class="grid">
        <div>
          <label for="formatSel">Format</label>
          <select id="formatSel">
            <option value="commander">Commander</option>
            <option value="modern">Modern</option>
            <option value="pioneer">Pioneer</option>
            <option value="standard">Standard</option>
          </select>
        </div>
        <div>
          <label for="budgetUsd">Budget cap (USD)</label>
          <input id="budgetUsd" type="number" min="0" step="1" placeholder="0 = no cap" />
        </div>
        <div>
          <label for="priceSource">Price source</label>
          <select id="priceSource">
            <option value="usd">USD (non-foil)</option>
            <option value="usd_foil">USD Foil</option>
            <option value="usd_etched">USD Etched</option>
          </select>
        </div>
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:12px;">
        <button id="closeSettings" type="button">Close</button>
        <button id="saveSettings" type="button">Save</button>
      </div>
    </div>
  </div>

  <!-- Optional site JS -->
  <script src="app.js"></script>

  <!-- Wiring to Worker + Markdown + hover linking + auto-expanding textarea -->
  <script>
  (function () {
    const API = "https://lexicon-proxy-holy-band-319a.biznuslobbstr.workers.dev";
    const form = document.getElementById("chatForm");
    const input = document.getElementById("prompt");
    const log = document.getElementById("log");
    const clearBtn = document.getElementById("clearBtn");
    const preview = document.getElementById("preview");
    const previewImg = preview.querySelector("img");

    // Auto-expand textarea as user types/pastes (infinite feel)
    function autosize() {
      input.style.height = "auto";
      input.style.height = Math.min(input.scrollHeight, window.innerHeight * 0.6) + "px";
    }
    input.addEventListener("input", autosize);
    window.addEventListener("resize", autosize);
    setTimeout(autosize, 0);

    const sessionId = (() => {
      try {
        const k = "lex_session";
        const v = localStorage.getItem(k) || (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()));
        localStorage.setItem(k, v);
        return v;
      } catch { return String(Date.now()); }
    })();

    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const text = (input.value || "").trim();
      if (!text) return;
      input.value = "";
      autosize();
      appendMessage("You", text, true);
      sendToWorker(text);
    });

    clearBtn.addEventListener("click", () => { log.innerHTML = ""; });

    function escapeHTML(s){
      return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]));
    }

    // Render with Markdown; then auto-link card names (no brackets required)
    function renderMarkdown(md) {
      const html = marked.parse(md || "", { breaks: true, gfm: true });
      const container = document.createElement("div");
      container.innerHTML = html;
      autoLinkCardNames(container);
      return container.innerHTML;
    }

    const cardCache = new Map(); // name -> {exists, img?}

    async function validateCardName(name) {
      const key = name.toLowerCase();
      if (cardCache.has(key)) return cardCache.get(key);
      try {
        const res = await fetch(`${API}/scryfall?q=${encodeURIComponent('!"' + name + '"')}`);
        const data = await res.json();
        const card = (data?.data && data.data[0]) || data;
        const img = card?.image_uris?.normal || card?.image_uris?.large ||
                    (card?.card_faces && card.card_faces[0]?.image_uris?.normal) || null;
        const exists = !!(card && (card.name || card.object === "card"));
        const info = { exists, img };
        cardCache.set(key, info);
        return info;
      } catch {
        const info = { exists:false };
        cardCache.set(key, info);
        return info;
      }
    }

    function autoLinkCardNames(rootEl) {
      const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
          if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
          const p = node.parentElement;
          if (!p) return NodeFilter.FILTER_REJECT;
          if (p.closest("code, pre, script, style")) return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        }
      });

      const textNodes = [];
      while (walker.nextNode()) textNodes.push(walker.currentNode);

      const MAX_VALID = 12;
      textNodes.forEach(async node => {
        let validationsLeft = MAX_VALID;
        const text = node.nodeValue;
        const tokens = text.split(/(\s+|[.,;:!?()‚Äì‚Äî-])/);

        async function tryRange(start, len) {
          if (validationsLeft <= 0) return false;
          const slice = tokens.slice(start, start + len);
          const raw = slice.join("");
          const clean = raw.trim();
          if (!clean) return false;

          if (!/^[A-Z]/.test(clean)) return false;
          if (!/[A-Za-z]/.test(clean)) return false;
          if (/^[A-Z0-9\s\-,'‚Äô:!]+$/.test(clean) && clean === clean.toUpperCase()) return false;

          const stop = ["The","And","Or","Of","To","For","With","A","An","At","In","On","By","As","It","This","That","You","Your","Phase","Combat","Main","End","Step","Turn"];
          if (len === 1 && stop.includes(clean)) return false;

          validationsLeft--;
          const info = await validateCardName(clean);
          if (!info.exists) return false;

          const span = document.createElement("span");
          span.className = "card-inline";
          span.setAttribute("data-card", clean);
          span.textContent = clean;

          const before = document.createTextNode(tokens.slice(0, start).join(""));
          const after  = document.createTextNode(tokens.slice(start + len).join(""));
          const parent = node.parentNode;
          const frag = document.createDocumentFragment();
          frag.appendChild(before);
          frag.appendChild(span);
          frag.appendChild(after);
          parent.replaceChild(frag, node);

          enableCardHovers(parent);
          return true;
        }

        (async () => {
          for (let i = 0; i < tokens.length; i++) {
            if (/\s+|[.,;:!?()‚Äì‚Äî-]/.test(tokens[i] || "")) continue;
            for (let len = 7; len >= 1; len--) {
              if (i + len > tokens.length) continue;
              const words = tokens.slice(i, i + len).filter(t => t && !/\s+|[.,;:!?()‚Äì‚Äî-]/.test(t)).length;
              if (words < 1 || words > 4) continue;
              const replaced = await tryRange(i, len);
              if (replaced || validationsLeft <= 0) return;
            }
          }
        })();
      });
    }

    function appendMessage(who, text, isUser = false) {
      const wrap = document.createElement("div");
      wrap.className = "msg";

      const name = document.createElement("div");
      name.className = "name " + (who === "Lexicon" ? "lexicon" : who === "You" ? "you" : "");
      name.textContent = who;

      const body = document.createElement("div");
      body.className = "body";
      if (isUser) {
        // Preserve line breaks for pasted decklists
        body.innerHTML = "<div style='white-space:pre-wrap'>" + escapeHTML(text) + "</div>";
      } else {
        body.innerHTML = renderMarkdown(text);
      }

      wrap.appendChild(name);
      wrap.appendChild(body);
      log.appendChild(wrap);
      log.scrollTop = log.scrollHeight;
      enableCardHovers(body);
    }

    async function loadCardImage(name) {
      const key = name.toLowerCase();
      const cached = cardCache.get(key);
      if (cached?.img) return cached.img;
      const info = await validateCardName(name);
      return info.img || null;
    }

    function enableCardHovers(root) {
      root.querySelectorAll(".card-inline[data-card]").forEach(span => {
        if (span.__hoverBound) return;
        span.__hoverBound = true;

        let active = false;
        const move = (ev) => {
          const pad = 12;
          const x = Math.min(window.innerWidth - 340, ev.clientX + pad);
          const y = Math.min(window.innerHeight - 360, ev.clientY + pad);
          preview.style.left = x + "px";
          preview.style.top  = y + "px";
        };

        span.addEventListener("mouseenter", async (e) => {
          active = true;
          preview.style.display = "block";
          preview.innerHTML = "Loading‚Ä¶";
          move(e);
          const name = span.getAttribute("data-card") || span.textContent.trim();
          try {
            const img = await loadCardImage(name);
            if (active && img) {
              preview.innerHTML = `<img alt="${name} preview" src="${img}">`;
            } else if (active) {
              preview.textContent = "Card not found.";
            }
          } catch {
            if (active) preview.textContent = "Error loading card.";
          }
        });

        span.addEventListener("mousemove", move);
        span.addEventListener("mouseleave", () => {
          active = false;
          preview.style.display = "none";
          preview.innerHTML = '<img alt="card preview">';
        });
      });
    }

    async function sendToWorker(text) {
      try {
        const res = await fetch(API + "/chat", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            sessionId,
            messages: [{ role: "user", content: text }]
          })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) {
          const msg = data && (data.error || data.text) ? `${data.error || data.text}` : `HTTP ${res.status}`;
          appendMessage("System", `**Error:** ${msg}`);
          return;
        }
        appendMessage("Lexicon", data.message || "(no content)");
      } catch (e) {
        appendMessage("System", `**Network error:** ${e}`);
      }
    }

    // Optional: quick health note
    (async () => {
      try {
        const h = await fetch(API + "/health").then(r => r.json());
        if (!h.ok) appendMessage("System", "Backend issue. Try again shortly.");
      } catch {
        appendMessage("System", "Cannot reach backend right now.");
      }
    })();
  })();
  </script>
</body>
</html>
